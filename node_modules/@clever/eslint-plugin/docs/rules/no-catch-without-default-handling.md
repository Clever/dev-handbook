# Prevents writing a catch block where the default case has no statements (no-catch-without-default-handling)

A common pattern in Clever's frontend servers is to differently handle specific error conditions from our backend services. 

In this case, we return a 404 when `teacher-pages-service` throws a `NotFound` error:
```ts
try {
  ({ resources, collection } = await Clients.collectionsLib.fetchCollection(
    session,
    collectionID,
    onIos,
  ));
} catch (err) {
  if (err instanceof tpsErrors.NotFound) {
    throw new NotFoundError("Teacher page not found");
  }
  throw err;
}
```

However, it's very easy to accidentally forget the `throw err`, as in:
```ts
try {
  ({ resources, collection } = await Clients.collectionsLib.fetchCollection(
    session,
    collectionID,
    onIos,
  ));
} catch (err) {
  if (err instanceof tpsErrors.NotFound) {
    throw new NotFoundError("Teacher page not found");
  }
}
```
This omission is bad because now we're swallowing all other errors, including 500s!

## Rule Details

This rule aims to prevent these omissions. Specifically, it looks for `catch` blocks where the "default" branch isn't handled - in other words, `catch` blocks where the only statements are in `if` statements (and there's no `else`). In cases where the swallowing is intentional, a comment can be added containing the word "swallow".

Examples of **incorrect** code for this rule:

```ts
try {
  ...
} catch (err) {
  if (err instanceof tpsErrors.NotFound) {
    throw new NotFoundError("Teacher page not found");
  }
}
```

```ts
try {
  ...
} catch (err) {}
```

Examples of **correct** code for this rule:

```ts
try {
  ...
} catch (err) {
  if (err instanceof tpsErrors.NotFound) {
    throw new NotFoundError("Teacher page not found");
  }
  doSomething();
}
```

```ts
try {
  ...
} catch (err) {
  if (err instanceof tpsErrors.NotFound) {
    throw new NotFoundError("Teacher page not found");
  } else {
    doSomething();
  }
}
```

```ts
try {
  ...
} catch (err) {
  if (err instanceof tpsErrors.NotFound) {
    throw new NotFoundError("Teacher page not found");
  }
  // We swallow other error types because ...
}
```

## Common False Positives
One example of false positive code looks like
```ts
try {
  ...
}
catch (err) {
  if (!(err instanceof tpsErrors.NotFound)) {
    throw err;
  }
}
```
In this case, this rule flags it as an error because it seems like the default case isn't being handled. Technically, the original code is fine since it inverts the logic to re-throw in a conditional and swallow in the default case.

To fix this, there are two general options. First, we can simply make the swallow explicit in the default branch
```ts
try {
  ...
}
catch (err) {
  if (!(err instanceof tpsErrors.NotFound)) {
    throw err;
  }
  // Swallow the NotFound error
}
```

Alternately, and sometimes preferred, we can invert the logic. This can be nice since it can be easier to read. However, the `else` is important since otherwise we always re-throw the error.
```ts
try {
  ...
}
catch (err) {
  if (err instanceof tpsErrors.NotFound) {
    // Swallow the NotFound error
  } else {
    throw err;
  }
}
```

## When Not To Use It

There may be some cases where swallowing an error is intended. In those cases, it's okay to disable this rule, but it's preferred to leave a comment containing the word "swallow" since that's better for documentation purposes - for example, explaining why we swallow the error.
